<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-27">

<title>Dynamic Make-to-Order Production: Mastering the Flow of Time – Himagineer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d68be38d83eca2bb035acf846ffba811.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Himagineer</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Dynamic Make-to-Order Production: Mastering the Flow of Time</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Inventory Management</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 27, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="managing-the-flow-of-time-in-make-to-order-production" class="level2">
<h2 class="anchored" data-anchor-id="managing-the-flow-of-time-in-make-to-order-production">Managing the Flow of Time in Make-to-Order Production</h2>
<p>In our series on dynamic production management, we have explored the distinctions between Make-to-Order (MTO) and Make-to-Stock (MTS) production, and the challenges associated with traditional production planning. This post delves deeper into <strong>Make-to-Order (MTO) production</strong>, focusing on the critical aspect of time management and how a dynamic approach can overcome the inherent problems. Our analysis is based on the insights provided by tocken.com regarding jucyu production [1].</p>
<section id="the-challenges-of-make-to-order-production" class="level3">
<h3 class="anchored" data-anchor-id="the-challenges-of-make-to-order-production">The Challenges of Make-to-Order Production</h3>
<p>While MTO production, where products are made only after a customer order is confirmed, might seem ideal (no unsold inventory, no complaints about stockouts), it presents its own set of significant challenges. A common issue is the ambiguity surrounding the definition of a “confirmed order.” This can lead to “premature starts” where production begins based on tentative orders, unconfirmed specifications, or unclear delivery dates. These premature starts are often driven by the pressure to meet tight deadlines, as delaying production until all details are finalized could mean missing the customer’s requested delivery date.</p>
<p>The low on-time delivery rate is a persistent problem in MTO production. Is this due to poor time management? To understand why time management is so difficult in MTO, we need to examine the underlying issues.</p>
<section id="fluctuating-time-elements" class="level4">
<h4 class="anchored" data-anchor-id="fluctuating-time-elements">Fluctuating Time Elements</h4>
<p>Several time elements are at play in MTO production:</p>
<ul>
<li><strong>Customer’s Desired Delivery Date:</strong> The date by which the customer expects the product to be completed and delivered.</li>
<li><strong>Production Lead Time:</strong> The estimated time required to produce the product. Subtracting this from the desired delivery date gives the planned production start (input) date.</li>
<li><strong>Order Confirmation Time:</strong> The actual time when the order is formally confirmed. Ideally, this should be before the planned production start date, but it often occurs later.</li>
</ul>
<p>The most critical of these for time management is the <strong>production lead time</strong>. A common problem is that the actual production lead time often exceeds the estimated lead time. Why does this happen? One major reason is the tendency to set extremely tight lead times to meet customer demands, especially in competitive environments.</p>
<p>The production lead time consists primarily of <strong>flow time</strong> (the time from input to completion) and administrative processing time before input. Flow time, in turn, is composed of processing time and <strong>waiting time</strong>. Waiting time dramatically increases when the load factor (utilization rate) of the production line approaches around 80%. Flow time exhibits a similar curve, and this phenomenon is referred to as the <strong>“flow time jump.”</strong> The more significant the variability, the steeper this jump becomes. Figure 1 illustrates this relationship:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../home/ubuntu/jucyu_figure1.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Change in Waiting Time vs.&nbsp;Load Factor</figcaption>
</figure>
</div>
<p>Figure 1: Change in Waiting Time vs.&nbsp;Load Factor</p>
<p>While a high utilization rate is generally considered desirable (e.g., 90% or even 95%), operating in this high-utilization zone leads to a sharp increase in flow time, making time management extremely difficult. This is a primary factor contributing to poor time and delivery management in MTO production.</p>
</section>
</section>
<section id="suppressing-the-flow-time-jump" class="level3">
<h3 class="anchored" data-anchor-id="suppressing-the-flow-time-jump">Suppressing the Flow Time Jump</h3>
<p>Before discussing time management, it’s essential to address the flow time jump. Without controlling this phenomenon, effective time management is impossible. Two main methods can suppress the flow time jump:</p>
<ol type="1">
<li><p><strong>Work-In-Process (WIP) Limit:</strong> Implementing an input restriction based on WIP is highly effective. As shown in Figure 2, reducing the WIP limit (e.g., from 50 to 20) significantly flattens the flow time jump curve.</p></li>
<li><p><strong>Increasing Production Capacity:</strong> Raising production capacity to keep the load factor below 80% also helps. In practice, a combination of these two methods is often employed.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../home/ubuntu/jucyu_figure2.png" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Flow Time Jump and WIP Limit</figcaption>
</figure>
</div>
<p>Figure 2: Flow Time Jump and WIP Limit</p>
</section>
<section id="setting-standard-manufacturing-lead-time-sml" class="level3">
<h3 class="anchored" data-anchor-id="setting-standard-manufacturing-lead-time-sml">Setting Standard Manufacturing Lead Time (SML)</h3>
<p>With methods to control the flow time jump in place, we can now return to time management. Traditional MTO production relies on production plans, schedules, and detailed timelines as benchmarks. However, as we’ve repeatedly seen, these are often unable to keep pace with demand fluctuations. So, what should be our benchmark?</p>
<p>The <strong>production lead time</strong> itself can serve as a benchmark, which we will call <strong>Standard Manufacturing Lead-time (SML)</strong>. This concept is analogous to standard work time or standard man-hours.</p>
<p>For SML to function effectively, its definition must be precise. The longest component of SML is typically the flow time. This is why controlling the flow time jump is so crucial. A key consideration is determining the maximum acceptable flow time. Flow time comprises processing time (for operations like machining and assembly) and waiting time (for machine availability, material arrival, or human-induced delays like batch processing or consolidation). Figure 3 shows an example of a <strong>Time In Process (TIP) chart</strong>, illustrating the flow time progression from production start to completion for a product group.</p>
<p>Completion times in MTO production vary and are generally approximated by a normal distribution, characterized by its mean and variance (standard deviation). Since MTO orders often have unique specifications, estimating SML for each individual order is ideal. However, for products with minor specification differences but largely repetitive production, grouping them by specification and setting SMLs for each group can be effective. The upper limit of flow time depends on the desired completion probability and is closely related to the degree of input restriction.</p>
<p>It’s also important to account for potential delays in input (start). Various factors, such as input restrictions to control flow time jump, material arrival delays, machine setup, or partial specification changes, can delay the planned production start. SML should incorporate an allowance for these anticipated delays.</p>
<p>Thus, SML can be expressed as:</p>
<p><span class="math display">\[SML = \text{Flow Time Upper Limit} + \text{Allowable Input Delay}\]</span></p>
</section>
<section id="dynamic-control-of-mto-production" class="level3">
<h3 class="anchored" data-anchor-id="dynamic-control-of-mto-production">Dynamic Control of MTO Production</h3>
<p>In a dynamic MTO system, the SML becomes the primary control parameter. Instead of rigid schedules, the system focuses on managing the flow of orders to ensure they adhere to their SML. This involves:</p>
<ul>
<li><strong>Real-time Progress Monitoring:</strong> Continuously tracking the progress of each order against its SML. Deviations trigger alerts, allowing for timely intervention.</li>
<li><strong>Priority Control:</strong> When multiple orders compete for resources, a dynamic priority control mechanism is needed. The website suggests using the ratio of elapsed time from input to the standard flow time as a priority criterion. Orders that are falling behind their SML would automatically gain higher priority.</li>
</ul>
<p>Let <span class="math inline">\(T_{elapsed}\)</span> be the elapsed time since input and <span class="math inline">\(SML_{order}\)</span> be the SML for a specific order. The priority <span class="math inline">\(P\)</span> could be defined as:</p>
<p><span class="math display">\[P = \frac{T_{elapsed}}{SML_{order}}\]</span></p>
<p>Orders with a higher <span class="math inline">\(P\)</span> value would be prioritized. This allows for autonomous priority control on the shop floor.</p>
</section>
<section id="input-management-and-progress-tracking" class="level3">
<h3 class="anchored" data-anchor-id="input-management-and-progress-tracking">Input Management and Progress Tracking</h3>
<p>Effective input management is crucial. Orders should only be input into the production system if they have a reasonable chance of meeting their SML. This requires a clear understanding of current capacity and WIP levels. Progress tracking should be granular, allowing for visibility into each order’s status at every stage of production.</p>
</section>
<section id="rules-and-maintenance" class="level3">
<h3 class="anchored" data-anchor-id="rules-and-maintenance">Rules and Maintenance</h3>
<p>Establishing clear rules for dynamic MTO is essential. These rules govern how orders are prioritized, how resources are allocated, and how deviations are handled. Regular maintenance of these rules and the underlying system is necessary to ensure continued effectiveness.</p>
</section>
<section id="information-processing-mechanism" class="level3">
<h3 class="anchored" data-anchor-id="information-processing-mechanism">Information Processing Mechanism</h3>
<p>A robust information processing mechanism is the backbone of dynamic MTO. This system needs to:</p>
<ul>
<li><strong>Collect Real-time Data:</strong> Gather data on order status, WIP levels, machine availability, and material status.</li>
<li><strong>Calculate SML and Priorities:</strong> Automatically compute SMLs for new orders and update priorities for ongoing orders.</li>
<li><strong>Provide Alerts and Insights:</strong> Generate alerts for potential delays or bottlenecks and provide insights into system performance.</li>
</ul>
</section>
<section id="performance-evaluation" class="level3">
<h3 class="anchored" data-anchor-id="performance-evaluation">Performance Evaluation</h3>
<p>Finally, the performance of the dynamic MTO system must be continuously evaluated. Key metrics would include:</p>
<ul>
<li><strong>On-time Delivery Rate:</strong> The percentage of orders delivered by their promised date.</li>
<li><strong>Actual vs.&nbsp;SML Deviation:</strong> The difference between actual production lead time and SML.</li>
<li><strong>Flow Time Variability:</strong> The consistency of flow times.</li>
<li><strong>Resource Utilization:</strong> While not the sole focus, efficient resource utilization remains important.</li>
</ul>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>Dynamic Make-to-Order production shifts the focus from rigid, static planning to the dynamic management of time and flow. By understanding and controlling the factors that influence flow time, setting realistic Standard Manufacturing Lead Times, and implementing intelligent priority and input control mechanisms, businesses can significantly improve their on-time delivery performance and overall responsiveness. This approach, rooted in real-time data and autonomous decision-making, is vital for navigating the complexities of modern MTO environments.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/okihik\.github\.io\/versatile-note\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>