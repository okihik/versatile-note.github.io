<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-25">

<title>Himagineer - Dynamic Inventory Theories: Unpacking Inventory Management Challenges</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Himagineer</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Dynamic Inventory Theories: Unpacking Inventory Management Challenges</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Inventory Management</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 25, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="bridging-the-gap-from-static-inventory-to-dynamic-flow" class="level2">
<h2 class="anchored" data-anchor-id="bridging-the-gap-from-static-inventory-to-dynamic-flow">Bridging the Gap: From Static Inventory to Dynamic Flow</h2>
<p>In our previous post, we introduced Dynamic Production Management (DPM) as a paradigm shift from traditional production planning to a demand-centric approach. Building upon that foundation, this post delves deeper into the intricacies of inventory management, specifically addressing why conventional methods often fall short in today’s dynamic business environment. We will explore the challenges posed by classical inventory theory and introduce the concept of “inventory flow management” as a more adaptive solution. Furthermore, we will formulate a basic <strong>Inventory Dynamic Model</strong> with relevant equations.</p>
<section id="the-historical-context-and-limitations-of-classical-inventory-theory" class="level3">
<h3 class="anchored" data-anchor-id="the-historical-context-and-limitations-of-classical-inventory-theory">The Historical Context and Limitations of Classical Inventory Theory</h3>
<p>Since the mid-19th to mid-20th century, characterized by mass production and a seller’s market, the primary focus was on efficiently increasing production volume and ensuring a smooth supply of materials. It was within this context that classical inventory management mechanisms were shaped. The fundamental principle was simple: reorder when stock levels drop to a certain point, much like how we manage everyday household items. This is the essence of the reorder point system.</p>
<p>However, this approach quickly encounters problems with materials that have long lead times (e.g., 3-6 months or more). Applying a reorder point system to such items can lead to excessive inventory or, conversely, frequent stockouts. To address this, methods like periodic replenishment were devised, where materials are ordered periodically based on future needs. While ideally linked to production plans, the unreliability of long-term production forecasts often meant that material procurement had to rely on independent forecasts.</p>
<p>Classical inventory theory, born from the management of factory material warehouses, is still prevalent today. However, the question arises: can this classical theory be applied to the diverse forms of inventory that exist now, including finished goods warehouses, regional distribution centers, wholesalers, retailers, in-process inventory within factories, and even materials at external suppliers? The conclusion, as presented by tocken.com, is a resounding “No.” The core issues lie in two critical aspects: <strong>asymmetry</strong> and the <strong>ambiguity of optimal inventory</strong>.</p>
</section>
<section id="asymmetry-in-inventory-management-a-mismatch-of-perspectives" class="level3">
<h3 class="anchored" data-anchor-id="asymmetry-in-inventory-management-a-mismatch-of-perspectives">Asymmetry in Inventory Management: A Mismatch of Perspectives</h3>
<p>Consider a typical inventory management scenario where entity A manages its inventory, fulfilling customer orders and replenishing stock by ordering from entity B. Both the ordering process from A to B and the customer order process to A involve recording order times and quantities. This commercial transaction data is meticulously managed. However, when this data is brought into the inventory management framework, a critical asymmetry emerges.</p>
<p>Inventory management fundamentally involves adjusting “input” (replenishment) to match “output” (demand). Therefore, both input and output must be measured with the same yardstick. Demand, being largely uncontrollable, must be accepted as it is, making it crucial to understand its magnitude, including its variability. Yet, classical inventory theory often overlooks this crucial aspect.</p>
<p>For instance, when forecasting demand for inventory management, say for a two-month lead time, do we separately forecast the number of orders and the quantity per order? Classical inventory theory typically does not. It often provides a single demand forecast (e.g., XXX units for two months) without breaking down the number of orders or the quantity per order. While we meticulously consider order intervals and quantities when placing orders, our view of demand tends to be broad and undifferentiated. This disparity in how “output” and “input” are perceived—using different lenses for logistics—is what constitutes <strong>asymmetry</strong>.</p>
<p>This asymmetry has significant implications. Consider two scenarios where the average demand over a period is 200 units: one with an average of 40 orders of 5 units each, and another with 10 orders of 20 units each. While the average total demand is the same, the variability will differ significantly. Intuitively, receiving many small orders is preferable to a few large ones for minimizing inventory. Therefore, to accurately capture demand variability, it is essential to consider the number of orders and the quantity per order separately.</p>
<p>Supply chains are interconnected networks of inventory management units. If the “output” and “input” are viewed from different perspectives, or if there is a lack of symmetry between them, the connections between these inventory management units become disjointed. From a physics perspective, symmetry is crucial for universality. Just as physical laws exhibit symmetry, suggesting their universal applicability, a lack of symmetry in inventory replenishment mechanisms implies a narrow scope for classical inventory theory.</p>
</section>
<section id="the-ambiguity-of-optimal-inventory" class="level3">
<h3 class="anchored" data-anchor-id="the-ambiguity-of-optimal-inventory">The Ambiguity of Optimal Inventory</h3>
<p>Let’s trace the flow of inventory through time: order received → shipment → inventory reduction → waiting for order → order placed → outstanding order → delivery → warehousing. Each event triggers a change in inventory status, and the quantity in each status fluctuates. It’s important to note that beyond physical stock in the warehouse, “inventory in transit” (waiting for order, outstanding order) often exists and can sometimes exceed physical stock. The quantity in each state increases or decreases with every event.</p>
<p>However, classical inventory theory struggles to define precisely what constitutes “optimal inventory.” While some explanations might include outstanding orders in the definition of optimal inventory, most often link it solely to physical stock. Regardless, the quantity in each state fluctuates, and even when combined, these quantities exhibit variability. In inventory management, “optimal inventory” is a crucial management criterion. Yet, in practice, it remains ambiguous which inventory state should be used for comparison.</p>
</section>
<section id="the-wave-of-dx-in-inventory-management" class="level3">
<h3 class="anchored" data-anchor-id="the-wave-of-dx-in-inventory-management">The Wave of DX in Inventory Management</h3>
<p>The recent surge in Digital Transformation (DX) initiatives highlights a growing concern: the increasing divergence between classical inventory theory and modern business realities. The need for DX in inventory management is urgent. The problems of “asymmetry” and “ambiguity of optimal inventory” inherent in classical theory are becoming more pronounced. The traditional approach, which assumes a stable environment and focuses on optimizing static inventory levels, is ill-equipped to handle the dynamic, interconnected, and data-rich landscape of today’s supply chains.</p>
<p>DX in inventory management is not merely about digitizing existing processes; it’s about fundamentally transforming how inventory is perceived and managed. It necessitates a shift towards real-time data utilization, predictive analytics, and agile decision-making. The goal is to move beyond simply counting stock to understanding the flow and behaviour of inventory across the entire supply chain, enabling proactive adjustments rather than reactive responses.</p>
</section>
<section id="basic-mechanism-of-inventory-replenishment-the-inventory-dynamic-model" class="level3">
<h3 class="anchored" data-anchor-id="basic-mechanism-of-inventory-replenishment-the-inventory-dynamic-model">Basic Mechanism of Inventory Replenishment: The Inventory Dynamic Model</h3>
<p>To overcome the limitations of classical inventory theory introduces the concept of an <strong>Inventory Dynamic Model</strong>. This model emphasizes understanding inventory not as static quantities but as dynamic flows within a system. It recognizes that inventory is constantly in motion, transitioning through various states from raw materials to finished goods, and that these flows are influenced by both internal processes and external demand.</p>
<p>We can conceptualize the inventory dynamic model using a set of differential equations that describe the change in inventory levels over time. Let <span class="math inline">\(I(t)\)</span> be the inventory level at time <span class="math inline">\(t\)</span>. The rate of change of inventory can be expressed as the difference between the inflow (replenishment rate) and the outflow (demand rate).</p>
<p>Let: * <span class="math inline">\(R(t)\)</span> = Replenishment rate (inflow) at time <span class="math inline">\(t\)</span> * <span class="math inline">\(D(t)\)</span> = Demand rate (outflow) at time <span class="math inline">\(t\)</span></p>
<p>The fundamental equation for the inventory dynamic model is:</p>
<p><span class="math display">\[ \frac{dI(t)}{dt} = R(t) - D(t) \]</span></p>
<p>This equation states that the rate of change of inventory over time is equal to the replenishment rate minus the demand rate. This is a continuous model, representing inventory as a dynamic that flows in and out of a system.</p>
<p>To further elaborate, we can consider the components of replenishment and demand. Replenishment can be influenced by factors such as lead time (<span class="math inline">\(L\)</span>), which is the time delay between placing an order and receiving it. Demand can be influenced by various market factors and can be stochastic.</p>
<p>Consider a simplified scenario where replenishment orders are placed based on a reorder point (<span class="math inline">\(S\)</span>) and a fixed order quantity (<span class="math inline">\(Q\)</span>). The replenishment rate <span class="math inline">\(R(t)\)</span> would then be a function of the orders placed at an earlier time <span class="math inline">\(t-L\)</span>. The demand rate <span class="math inline">\(D(t)\)</span> would be a function of customer orders.</p>
<p>For a more detailed model, we can consider different stages of inventory, such as raw materials, work-in-process (WIP), and finished goods. Let <span class="math inline">\(I_{raw}(t)\)</span>, <span class="math inline">\(I_{wip}(t)\)</span>, and <span class="math inline">\(I_{fg}(t)\)</span> be the inventory levels for raw materials, WIP, and finished goods, respectively.</p>
<p>Let: * <span class="math inline">\(P_{raw}(t)\)</span> = Procurement rate of raw materials at time <span class="math inline">\(t\)</span> * <span class="math inline">\(C_{raw}(t)\)</span> = Consumption rate of raw materials for production at time <span class="math inline">\(t\)</span> * <span class="math inline">\(P_{wip}(t)\)</span> = Production rate into WIP at time <span class="math inline">\(t\)</span> * <span class="math inline">\(C_{wip}(t)\)</span> = Consumption rate from WIP for finished goods production at time <span class="math inline">\(t\)</span> * <span class="math inline">\(P_{fg}(t)\)</span> = Production rate of finished goods at time <span class="math inline">\(t\)</span> * <span class="math inline">\(D_{fg}(t)\)</span> = Demand rate for finished goods at time <span class="math inline">\(t\)</span></p>
<p>Then, the system can be described by a set of coupled differential equations:</p>
<p><span class="math display">\[ \frac{dI_{raw}(t)}{dt} = P_{raw}(t) - C_{raw}(t) \]</span></p>
<p><span class="math display">\[ \frac{dI_{wip}(t)}{dt} = P_{wip}(t) - C_{wip}(t) \]</span></p>
<p><span class="math display">\[ \frac{dI_{fg}(t)}{dt} = P_{fg}(t) - D_{fg}(t) \]</span></p>
<p>These equations highlight the interconnectedness of different inventory stages and the continuous flow of materials through the supply chain. The “asymmetry” discussed earlier can be addressed by ensuring that the measurement and forecasting of <span class="math inline">\(P(t)\)</span> and <span class="math inline">\(D(t)\)</span> are consistent and account for the variability in both order frequency and quantity.</p>
<p>The “ambiguity of optimal inventory” can be resolved by considering the optimal levels for each stage of inventory (<span class="math inline">\(I_{raw}\)</span>, <span class="math inline">\(I_{wip}\)</span>, <span class="math inline">\(I_{fg}\)</span>) and their combined effect on the overall system performance, rather than focusing solely on physical stock. The goal is to optimize the flow and minimize bottlenecks, ensuring that inventory is available where and when needed, without excessive holding costs.</p>
<p>By adopting an inventory dynamic perspective, businesses can gain a more accurate and holistic understanding of their inventory dynamics. This enables them to:</p>
<ul>
<li><strong>Improve Responsiveness:</strong> By understanding real-time flow, businesses can react more quickly to demand changes and disruptions.</li>
<li><strong>Reduce Variability:</strong> A symmetrical view of input and output helps in managing and reducing the inherent variability in inventory levels.</li>
<li><strong>Optimize Resource Utilization:</strong> By accurately tracking inventory in all states, businesses can avoid overstocking or understocking, leading to better utilization of capital and space.</li>
<li><strong>Enhance Decision-Making:</strong> With a clearer picture of inventory flow, decision-makers can make more informed choices regarding procurement, production, and distribution.</li>
</ul>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>The challenges posed by classical inventory theory—namely, asymmetry and the ambiguity of optimal inventory—underscore the urgent need for a more dynamic approach. The Inventory Dynamic Model offers a promising solution by shifting the focus from static stock levels to the continuous flow of inventory throughout the supply chain. This aligns perfectly with the principles of Dynamic Production Management and the broader trend of Digital Transformation.</p>
<p>In future posts, we will delve deeper into the practical applications and advanced concepts of inventory flow management, exploring how businesses can implement these theories to achieve greater efficiency, responsiveness, and resilience in their operations.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>